# ch1

## ディレクトリの指定

GOPATH環境変数でモジュールのパスを指定する

現在ではGOROOTは不要

## go install

`go install ソースコードリポジトリ@バージョン`

ツールなどのインストールに

## lintとvet

vetは潜在的なエラーを検知してくれる

golangci-lintを使うと複数のツールを一緒に実行できる

## Makefile

goではmakeをつかう

# ch2

## ルーンリテラル

シングルクォートで囲った文字,ダブルクォートではない

## 文字列リテラル

ダブルクォートでかこう
改行を含めたいときはバッククォートが便利

## リテラルと型

サイズが異なる場合、演算不可。リテラルに墓tがないので整数、小数などの演算は可能

## rune型

int32のエイリアス、明確に文字を参照している場合はこちらをつかう


## 変数の宣言

:=が使えるのは関数内のみ

ゼロ値外とされていることを明確にしたい場合は`var hoge int`などとしたほうがいい

bad x:=byte(20)
good var x byte=20

## 定数

constはリテラルに名前をつけるもの

一部の組み込み関数(complex,real,imag,len,cap)も結果も入れられる

型をつけることも可能

# ch3

## 配列

大きさを表す整数の代わりに...がつかえる

## スライス

スライス同士の比較はできない。比較可能なのはnilのみ
makeでlen,capを指定して作成可能

var x:=[]int{} != var x []int

## rune

UTF-8を含む文字列の場合、runeのスライスではなくstringsやurf8の関数を使うほうがよい

## map

カンマ,okイディオムでデフォルト値かゼロ値かを判定できる

## 構造体

からの構造体リテラルを代入することと、値を代入しないことの差はなく、ゼロ値で初期化される

# ch4

stringをfor-rangeでまわしたとき、runeで扱われる

# ch5

名前付き戻り値は意図を宣言するものであり要求するものではない

データの流れがわかりにくくなる、ブランクreturnに注意

クロージャーはLIFOなので最後にdeferされたものが最初に実行される

名前付き戻り値でdefer内でerrを補足するなどできる

goではstructも値渡し

# ch6

Cなどと違ってポインタ操作はできない

基本型のリテラルの前に&をつけることはできない