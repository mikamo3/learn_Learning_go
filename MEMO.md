# ch1

## ディレクトリの指定

GOPATH環境変数でモジュールのパスを指定する

現在ではGOROOTは不要

## go install

`go install ソースコードリポジトリ@バージョン`

ツールなどのインストールに

## lintとvet

vetは潜在的なエラーを検知してくれる

golangci-lintを使うと複数のツールを一緒に実行できる

## Makefile

goではmakeをつかう

# ch2

## ルーンリテラル

シングルクォートで囲った文字,ダブルクォートではない

## 文字列リテラル

ダブルクォートでかこう
改行を含めたいときはバッククォートが便利

## リテラルと型

サイズが異なる場合、演算不可。リテラルに墓tがないので整数、小数などの演算は可能

## rune型

int32のエイリアス、明確に文字を参照している場合はこちらをつかう


## 変数の宣言

:=が使えるのは関数内のみ

ゼロ値外とされていることを明確にしたい場合は`var hoge int`などとしたほうがいい

bad x:=byte(20)
good var x byte=20

## 定数

constはリテラルに名前をつけるもの

一部の組み込み関数(complex,real,imag,len,cap)も結果も入れられる

型をつけることも可能

# ch3

## 配列

大きさを表す整数の代わりに...がつかえる

## スライス

スライス同士の比較はできない。比較可能なのはnilのみ
makeでlen,capを指定して作成可能

var x:=[]int{} != var x []int

## rune

UTF-8を含む文字列の場合、runeのスライスではなくstringsやurf8の関数を使うほうがよい

## map

カンマ,okイディオムでデフォルト値かゼロ値かを判定できる

## 構造体

からの構造体リテラルを代入することと、値を代入しないことの差はなく、ゼロ値で初期化される

# ch4

stringをfor-rangeでまわしたとき、runeで扱われる

# ch5

名前付き戻り値は意図を宣言するものであり要求するものではない

データの流れがわかりにくくなる、ブランクreturnに注意

クロージャーはLIFOなので最後にdeferされたものが最初に実行される

名前付き戻り値でdefer内でerrを補足するなどできる

goではstructも値渡し

# ch6

Cなどと違ってポインタ操作はできない

基本型のリテラルの前に&をつけることはできない

# ch7

## goの型

抽象型と具象型がある。

抽象型：何をするものかを定義するがどのようにするかは規定しない。つまり抽象型は実装を提供しない

具象型：何をどのようにするかを期待する。つまりデータの記憶のされ方を規定した上で方に付随して定義されるメソッドの実装を提供する

全ての型はベースとなる基底型をもっている

関数同様メソッドはオーバーロードできない

メソッド宣言は型を宣言した同じパッケージでしかできない

## ポインタ型レシーバと値型レシーバ

ポインタ型レシーバを使用しないといけないときは、メソッドがレシーバを変更するとき、メソッドがnilを扱うとき

## itoa

使いどころは内部的な目的に限る。つまり定数が値ではなく名前で参照されるところ:w

## インタフェース

プログラムはインターフェースを受取り、構造体を返すようにコードを描くのが良い

インターフェースを返すとデカップリングとなって具象型からきりはなされる

インターフェースを返さないもう一つの理由はバージョン管理。具体的な型が返されるなら既存のコードを壊すことなくメソッドなどを追加できる

インターフェースがnilであるかどうかはそのインタフェースに関するメソッドを起動できるかどうかを示す

## 型アサーション

## 関数型とインターフェース

使い分け：一つの関数が多くの他の関数や引数でない、他の状態変数に依存するときインターフェースを引数として使う。そして関数をそのインターフェースにつなぐための関数型を定義する

sort.sliceのような単純なものであれば関数型の引数を使う