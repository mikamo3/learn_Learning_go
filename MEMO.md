# ch1

## ディレクトリの指定

GOPATH環境変数でモジュールのパスを指定する

現在ではGOROOTは不要

## go install

`go install ソースコードリポジトリ@バージョン`

ツールなどのインストールに

## lintとvet

vetは潜在的なエラーを検知してくれる

golangci-lintを使うと複数のツールを一緒に実行できる

## Makefile

goではmakeをつかう

# ch2

## ルーンリテラル

シングルクォートで囲った文字,ダブルクォートではない

## 文字列リテラル

ダブルクォートでかこう
改行を含めたいときはバッククォートが便利

## リテラルと型

サイズが異なる場合、演算不可。リテラルに墓tがないので整数、小数などの演算は可能

## rune型

int32のエイリアス、明確に文字を参照している場合はこちらをつかう


## 変数の宣言

:=が使えるのは関数内のみ

ゼロ値外とされていることを明確にしたい場合は`var hoge int`などとしたほうがいい

bad x:=byte(20)
good var x byte=20

## 定数

constはリテラルに名前をつけるもの

一部の組み込み関数(complex,real,imag,len,cap)も結果も入れられる

型をつけることも可能

# ch3

## 配列

大きさを表す整数の代わりに...がつかえる

## スライス

スライス同士の比較はできない。比較可能なのはnilのみ
makeでlen,capを指定して作成可能

var x:=[]int{} != var x []int

## rune

UTF-8を含む文字列の場合、runeのスライスではなくstringsやurf8の関数を使うほうがよい

## map

カンマ,okイディオムでデフォルト値かゼロ値かを判定できる

## 構造体

からの構造体リテラルを代入することと、値を代入しないことの差はなく、ゼロ値で初期化される

# ch4

stringをfor-rangeでまわしたとき、runeで扱われる

# ch5

名前付き戻り値は意図を宣言するものであり要求するものではない

データの流れがわかりにくくなる、ブランクreturnに注意

クロージャーはLIFOなので最後にdeferされたものが最初に実行される

名前付き戻り値でdefer内でerrを補足するなどできる

goではstructも値渡し

# ch6

Cなどと違ってポインタ操作はできない

基本型のリテラルの前に&をつけることはできない

# ch7

## goの型

抽象型と具象型がある。

抽象型：何をするものかを定義するがどのようにするかは規定しない。つまり抽象型は実装を提供しない

具象型：何をどのようにするかを期待する。つまりデータの記憶のされ方を規定した上で方に付随して定義されるメソッドの実装を提供する

全ての型はベースとなる基底型をもっている

関数同様メソッドはオーバーロードできない

メソッド宣言は型を宣言した同じパッケージでしかできない

## ポインタ型レシーバと値型レシーバ

ポインタ型レシーバを使用しないといけないときは、メソッドがレシーバを変更するとき、メソッドがnilを扱うとき

## itoa

使いどころは内部的な目的に限る。つまり定数が値ではなく名前で参照されるところ:w

## インタフェース

プログラムはインターフェースを受取り、構造体を返すようにコードを描くのが良い

インターフェースを返すとデカップリングとなって具象型からきりはなされる

インターフェースを返さないもう一つの理由はバージョン管理。具体的な型が返されるなら既存のコードを壊すことなくメソッドなどを追加できる

インターフェースがnilであるかどうかはそのインタフェースに関するメソッドを起動できるかどうかを示す

## 型アサーション

## 関数型とインターフェース

使い分け：一つの関数が多くの他の関数や引数でない、他の状態変数に依存するときインターフェースを引数として使う。そして関数をそのインターフェースにつなぐための関数型を定義する

sort.sliceのような単純なものであれば関数型の引数を使う

# ch8

## error

Newでエラーを返すときは最初小文字、ピリオドはつけない

エラーを返すには

* errors.Newをつかう
* fmt.Errorfをつかう

## センチネルエラー

現在の状態に問題があり、処理が継続できないことを知らせることを目的にしている

## エラーと値

独自のエラーを返す場合、初期化されていないインスタンスを返してはいけない

* 明示的にnilを返す
* errorを保持している任意のローカル変数をエラー型として返す

## エラーのラップ

カスタマイズされたエラー型でラップしたい場合、Unwrapを実装する

## IsとAs

センチネルエラーがラップされると==でちぇっくはできない。

戻されたエラー、あるいはラップされたその他のエラーが特定のセンチネルエラーのインスタンスにマッチするかを判定するerrors.Isをつかう

戻されたエラーが特定の型にマッチするかを判定するにはerrors.Asをつかう

## deferを使ったエラーのラップ

異なる事象のエラーに同じメッセージでラップしたいときに使う

## パニックとリカバー

recoverはdeferの中で呼び出さないといけない

利用目的はgracefulに処理を終了することで実行を継続は推奨されない

# ch9

## リポジトリ、モジュール、パッケージ

* リポジトリ、ソースコードの保存場所でVCSが備わっている
* モジュール、アプリケーションのルーロでリポジトリに保存される。複数のパッケージから構成される

importは標準パッケージ以外の場合、インポートパスを指定する必要がある

同じモジュール内のパッケージをインポートする場合、総体バスを指定できるが推奨されない

## パッケージの命名

utilなどよりもそのパッケージによって提供される機能を表現するパッケージ名にする

パッケージの名前をそのパッケージ内の関数や型の名前で繰り返すのは避けるべき

## godoc

ドキュメント対象とする項目の直前にコメントを置く

パッケージ宣言前に置かれたコメントはパッケージレベルのコメントになる

長いコメントはdoc.goにまとめる

## init関数

明示的に呼び出さずとも実行される関数

入力も出力も行わない

複数定義できる

主な用途はパッケージレベルの変数の初期化

## 循環参照

許可されていない

## モジュールプロキシサーバ

go getは直接リポジトリから取得せず、googleが運営しているプロキシサーバを経由する

リクエストをgoogleに贈りたくないとき、GOPROXYをdirectに設定する,ただし削除されたバージョンに依存している場合、アクセスできなくなる

サードパーティのプロキシもある

プライベートリポジトリを利用する場合、GOPRIVATEで対象のドメインを設定する

# ch10

並行処理、並行性は一つの処理を独立した複数のコンポーネントに分割し、コンポーネント間で安全にデータを共有しながら計算をすること

チャネルは一度だけ読み込み可能,複数のごルーチンが読み込みを行っている場合、そのうちの一つのみ読み込まれる

基本的にバッファリングされていないチャネルを使うべき

クローズされたchから値を読もうとすると常に成功する。かんまOKイディオムでオープンかどうか確認する

## 並行処理のベストプラクティス

* APIに平行性は含めない
  * APIとして公開する型、関数、メソッドにチャネルを含めないようにする
* ゴルーチンを起動するのに使用するクロージャーに引数がない場合、かつループ内ではシャドーイングするかクロージャーに引数を渡す
* ゴルーチンリークを防ぐため、関数は確実に終了するようにする
  * doneチャネルパターン
  * キャンセレーション関数

## いつバッファ付きのチャネルを使うべきか

ゴルーチンをいくつ起動したかがわかっており、起動するゴルーチンを制限したい

バッファに入ったものの処理に制限をかけたい


バックプレッシャ: 特定のコンポーネントの仕事の量を制限してシステムが全体として効率よく動作するように、バッファ付きチャネルとselect文を使って同時リクエストの数を制限する

caseにおいてnilチャネルからの読み込みは値を返さないのでcaseは実行されない

caseでtime.Afterを設けるとtimeoutが実装可能

## waitgroup

協調の第一選択肢とはするべきではない。ゴルーチンがすべて終了したあとでクリーンアップが必要なものがあるときのみ用いる